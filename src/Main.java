import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.image.Image;
import javafx.scene.input.*;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;
import javafx.util.Duration;

import java.io.IOException;
import java.util.*;

// TODO - Redo the javadoc comment (THIS POOP IS SO FISHED UP)
/**
 *Represents the main game logic and state managment for the Boulder Game
 *This class initilises the game window, recieves user input and
 *handles the rendering and updating of game state
 *The game a grid based level system with entities modelled on
 *top of it using javafx for rendering

 * @author James Harvey, Luke Brace, Joseph Vinson, Joe Devlin
 * Represents the game state, stores level data and renders game window
 */
public class Main extends Application {

    // title.
    public static final String GAME_TITLE = "Boulder Dash";

    // canvas. canvas is contained within window.
    public static final int CANVAS_WIDTH = 750;
    public static final int CANVAS_HEIGHT = 400;
    private Canvas canvas;

    public static final int GRID_CELL_WIDTH = 25;
    public static final int GRID_CELL_HEIGHT = 25;

    // control registering -> actively held keys.
    private final Queue<KeyCode> pressedKeys = new LinkedList<>();
    private final HashSet<KeyCode> seenKeys = new HashSet<>();

    // viewing system for managing the visible area of the game
    public static final View view = new View(1);

    // TODO - maybe better description for the parameter tag
    /**
     * Method used to set off the game. Sets up the GUI to display the current view,
     * tells Game to load the level, sets events to handle pressing and releasing keys
     * via helper functions and sets up timeline for calling tick method.
     * @param primaryStage The stage that is to be used for the application.
     */
    @Override
    public void start(Stage primaryStage) throws IOException {
        //Declare new canvas
        canvas = new Canvas(CANVAS_WIDTH, CANVAS_HEIGHT);

        // setting the scene.
        BorderPane root = FXMLLoader.load(Objects.requireNonNull(getClass().getResource("layout.fxml")));
        Scene scene = new Scene(root, CANVAS_WIDTH, CANVAS_HEIGHT);
        root.setCenter(canvas);

        // setting the stage.
        primaryStage.setTitle(GAME_TITLE);
        primaryStage.setScene(scene);
        primaryStage.show();

        // setting control registering
        scene.addEventFilter(KeyEvent.KEY_PRESSED, this::handleKeyPressed);
        scene.addEventFilter(KeyEvent.KEY_RELEASED, this::handleKeyReleased);

        // load the cave.
        Game.loadingCave();

        // setting tick-based system.
        Timeline tickTimeline = new Timeline(new KeyFrame(Duration.millis(125), event -> tick()));
        tickTimeline.setCycleCount(Animation.INDEFINITE);
        tickTimeline.play();
    }

    // TODO - maybe better description for the event parameter
    /**
     * If a key has not already been seen by the program as having been pressed
     * it is added to the queue of pressed keys and the hash set of seensKeys
     * @param event Even generated by key being pressed
     */
    public void handleKeyPressed(KeyEvent event) {
        if (!seenKeys.contains(event.getCode())) {
            pressedKeys.add(event.getCode());
            seenKeys.add(event.getCode());
        }
        event.consume();
    }

    // TODO - javadoc method comment
    public void handleKeyReleased(KeyEvent event) {
        pressedKeys.remove(event.getCode());
        seenKeys.remove(event.getCode());
        event.consume();
    }

    /**
     * This method is called periodically by the tick timeline,
     * allowing the Game class to call its own tick function,
     * which in turn triggers the tick function of any entity
     * on the map that needs to be updated every tick
     */
    public void tick() {
        if (!pressedKeys.isEmpty()) {
            Player p = Player.getPlayer();
            KeyCode intendedKey = pressedKeys.peek();
            p.move(intendedKey);
        }
        Game.getGame().tick();
        draw();
    }

    // TODO - javadoc comment
    // TODO - display the score
    // TODO - better separation of responsibilities
    private void draw() {
        GraphicsContext gc = canvas.getGraphicsContext2D();
        gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        gc.setFill(Color.BLACK);
        gc.fillRect(0, 0, canvas.getWidth(), canvas.getHeight());

        int[] whatWeCanSee = view.getViewable();
        int xStart = whatWeCanSee[0];
        int xEnd = whatWeCanSee[1];
        int yStart = whatWeCanSee[2];
        int yEnd = whatWeCanSee[3];

        Entity[][] mapWeCanSee = new Entity[16][30];

        for (int y = yStart; y <= yEnd; y++) {
            for (int x = xStart; x <= xEnd; x++) {
                mapWeCanSee[y - yStart][x - xStart] = Game.getGame().getMap()[y][x];
            }
        }

        for (int y = 0; y < 16; y++) {
            for (int x = 0; x < 30; x++) {
                Entity entity = mapWeCanSee[y][x];
                Image sprite = entity.getSprite();
                gc.drawImage(sprite, x * GRID_CELL_WIDTH, y * GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
            }
        }
    }

    // TODO - javadoc method comment
    public static void main(String[] args) {
        Game.getGame();
        launch(args);
    }
}
